name: iOS TestFlight

on:
  workflow_dispatch:  # Manual trigger only

permissions:
  contents: read

concurrency:
  group: ios-testflight
  cancel-in-progress: true  # Cancel older TestFlight builds if a new push comes in

env:
  BUNDLE_ID: com.devil.phoenixproject.projectphoenix
  SCHEME: VitruvianPhoenix
  PROJECT_PATH: iosApp/VitruvianPhoenix/VitruvianPhoenix.xcodeproj
  GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx8g -XX:+UseParallelGC -XX:MaxMetaspaceSize=1g"

jobs:
  build-and-upload:
    runs-on: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Cache Kotlin/Native compiler
        uses: actions/cache@v4
        with:
          path: ~/.konan
          key: ${{ runner.os }}-konan-2.3.0-iosArm64
          restore-keys: |
            ${{ runner.os }}-konan-2.3.0-
            ${{ runner.os }}-konan-

      - name: Auto-increment build number
        id: build_number
        run: |
          # Generate build number from date and run number
          BUILD_NUM=$(date +%Y%m%d)${{ github.run_number }}
          echo "build_number=$BUILD_NUM" >> $GITHUB_OUTPUT
          echo "Build number: $BUILD_NUM"

          # Update Xcode project with new build number
          sed -i '' "s/CURRENT_PROJECT_VERSION = [0-9]*/CURRENT_PROJECT_VERSION = $BUILD_NUM/g" \
            iosApp/VitruvianPhoenix/VitruvianPhoenix.xcodeproj/project.pbxproj

          # Also update Info.plist for consistency
          sed -i '' "s/<string>[0-9]*<\/string><!-- CFBundleVersion -->/<string>$BUILD_NUM<\/string><!-- CFBundleVersion -->/g" \
            iosApp/VitruvianPhoenix/VitruvianPhoenix/Info.plist || true

          # Show what was set
          grep "CURRENT_PROJECT_VERSION" iosApp/VitruvianPhoenix/VitruvianPhoenix.xcodeproj/project.pbxproj | head -2

      - name: Build shared framework and resources
        run: |
          # Build the framework
          ./gradlew :shared:linkReleaseFrameworkIosArm64 --no-parallel
          # Explicitly generate compose resources for iOS
          ./gradlew :shared:generateComposeResClass
          ./gradlew :shared:iosArm64ProcessResources || true

          # Debug: Show what resource directories exist
          echo "=== Checking resource directories ==="
          find shared/build -type d -name "composeResources" 2>/dev/null | head -10
          find shared/build -name "vitphoe_logo.png" 2>/dev/null | head -5

      - name: Copy Compose resources to framework bundle
        run: |
          # Compose MP looks for resources in the framework bundle when embedded as dynamic framework
          # Copy resources into shared.framework so they can be found at runtime
          # IMPORTANT: This must happen BEFORE creating XCFramework or symlinks
          FRAMEWORK_PATH="shared/build/bin/iosArm64/releaseFramework/shared.framework"
          RESOURCE_DST="$FRAMEWORK_PATH/composeResources"
          mkdir -p "$RESOURCE_DST"

          # Try multiple possible source paths (Compose MP resource generation varies by version)
          RESOURCE_PATHS=(
            "shared/build/processedResources/iosArm64/main/composeResources"
            "shared/build/kotlin-multiplatform-resources/aggregated-resources/iosArm64/composeResources"
            "shared/build/generated/compose/resourceGenerator/assembledResources/iosArm64Main/composeResources"
            "shared/build/generated/compose/resourceGenerator/preparedResources/commonMain/composeResources"
          )

          FOUND=false
          for RESOURCE_SRC in "${RESOURCE_PATHS[@]}"; do
            echo "Checking: $RESOURCE_SRC"
            if [ -d "$RESOURCE_SRC" ] && [ "$(ls -A "$RESOURCE_SRC" 2>/dev/null)" ]; then
              echo "Found compose resources at: $RESOURCE_SRC"
              cp -R "$RESOURCE_SRC"/* "$RESOURCE_DST"/
              FOUND=true
              break
            fi
          done

          if [ "$FOUND" = true ]; then
            echo "=== Copied compose resources to framework bundle ==="
            find "$RESOURCE_DST" -type f | head -20
          else
            echo "ERROR: No compose resources found!"
            echo "Checked paths:"
            printf '  - %s\n' "${RESOURCE_PATHS[@]}"
            exit 1
          fi

      - name: Create XCFramework
        run: |
          xcodebuild -create-xcframework \
            -framework shared/build/bin/iosArm64/releaseFramework/shared.framework \
            -output shared/build/XCFrameworks/release/shared.xcframework

      - name: Link framework to Xcode path
        run: |
          mkdir -p shared/build/bin/iosArm64/debugFramework
          ln -sfn ../releaseFramework/shared.framework shared/build/bin/iosArm64/debugFramework/shared.framework

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app/Contents/Developer

      - name: Install certificate and profile
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          PROVISION_PROFILE_BASE64: ${{ secrets.PROVISION_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          echo -n "$PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles

      - name: Archive app
        run: |
          xcodebuild archive \
            -project "$PROJECT_PATH" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath $RUNNER_TEMP/VitruvianPhoenix.xcarchive \
            DEVELOPMENT_TEAM="${{ secrets.TEAM_ID }}" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="${{ secrets.PROVISIONING_PROFILE_NAME }}"

      - name: Export .ipa
        run: |
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/VitruvianPhoenix.xcarchive \
            -exportPath $RUNNER_TEMP/export \
            -exportOptionsPlist iosApp/ExportOptions.plist

      - name: Upload to TestFlight
        env:
          APPSTORE_API_KEY: ${{ secrets.APPSTORE_API_KEY }}
          APPSTORE_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "$APPSTORE_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APPSTORE_API_KEY_ID}.p8

          xcrun altool --upload-app \
            -f "$RUNNER_TEMP/export/VitruvianPhoenix.ipa" \
            --type ios \
            --apiKey "$APPSTORE_API_KEY_ID" \
            --apiIssuer "$APPSTORE_ISSUER_ID"

      - name: Add build to TestFlight test group
        env:
          APPSTORE_API_KEY: ${{ secrets.APPSTORE_API_KEY }}
          APPSTORE_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          TESTFLIGHT_GROUP_NAME: ${{ secrets.TESTFLIGHT_GROUP_NAME }}  # e.g., "Internal Testers"
        run: |
          set -e

          # Generate JWT for App Store Connect API
          generate_jwt() {
            local header=$(echo -n '{"alg":"ES256","kid":"'"$APPSTORE_API_KEY_ID"'","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
            local now=$(date +%s)
            local exp=$((now + 1200))
            local payload=$(echo -n '{"iss":"'"$APPSTORE_ISSUER_ID"'","iat":'"$now"',"exp":'"$exp"',"aud":"appstoreconnect-v1"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
            local unsigned="$header.$payload"
            local key_file=~/.appstoreconnect/private_keys/AuthKey_${APPSTORE_API_KEY_ID}.p8
            local signature=$(echo -n "$unsigned" | openssl dgst -sha256 -sign "$key_file" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
            echo "$unsigned.$signature"
          }

          JWT=$(generate_jwt)
          API_BASE="https://api.appstoreconnect.apple.com/v1"

          echo "=== Waiting for build to process (this may take several minutes) ==="

          # Get App ID
          APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            "$API_BASE/apps?filter[bundleId]=$BUNDLE_ID")
          APP_ID=$(echo "$APP_RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin)['data'][0]['id'])")
          echo "App ID: $APP_ID"

          # Get beta group ID
          GROUPS_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            "$API_BASE/apps/$APP_ID/betaGroups")
          GROUP_ID=$(echo "$GROUPS_RESPONSE" | python3 -c "
          import sys,json
          data = json.load(sys.stdin)
          target = '$TESTFLIGHT_GROUP_NAME'
          for g in data['data']:
              if g['attributes']['name'] == target:
                  print(g['id'])
                  break
          ")
          echo "Beta Group ID: $GROUP_ID"

          if [ -z "$GROUP_ID" ]; then
            echo "ERROR: Could not find beta group '$TESTFLIGHT_GROUP_NAME'"
            echo "Available groups:"
            echo "$GROUPS_RESPONSE" | python3 -c "import sys,json; [print('  -', g['attributes']['name']) for g in json.load(sys.stdin)['data']]"
            exit 1
          fi

          # Wait for build to finish processing (check every 30 seconds, max 20 minutes)
          BUILD_ID=""
          BUILD_VERSION="${{ steps.build_number.outputs.build_number }}"

          for i in {1..40}; do
            # Refresh JWT if needed (they expire after 20 min)
            if [ $((i % 20)) -eq 0 ]; then
              JWT=$(generate_jwt)
            fi

            BUILDS_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
              "$API_BASE/builds?filter[app]=$APP_ID&filter[version]=$BUILD_VERSION&limit=1")

            BUILD_STATUS=$(echo "$BUILDS_RESPONSE" | python3 -c "
          import sys,json
          data = json.load(sys.stdin)
          if data.get('data'):
              b = data['data'][0]
              status = b['attributes'].get('processingState', 'UNKNOWN')
              print(status)
          else:
              print('NOT_FOUND')
          " 2>/dev/null || echo "NOT_FOUND")

            echo "Build status: $BUILD_STATUS (attempt $i/40)"

            if [ "$BUILD_STATUS" = "VALID" ]; then
              BUILD_ID=$(echo "$BUILDS_RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin)['data'][0]['id'])")
              break
            elif [ "$BUILD_STATUS" = "INVALID" ]; then
              echo "ERROR: Build is invalid and cannot be distributed"
              exit 1
            fi

            sleep 30
          done

          if [ -z "$BUILD_ID" ]; then
            echo "ERROR: Build did not finish processing in time"
            exit 1
          fi

          echo "Build ID: $BUILD_ID"

          # Add build to beta group
          echo "=== Adding build to test group '$TESTFLIGHT_GROUP_NAME' ==="
          ADD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Content-Type: application/json" \
            -d '{"data":[{"type":"builds","id":"'"$BUILD_ID"'"}]}' \
            "$API_BASE/betaGroups/$GROUP_ID/relationships/builds")

          HTTP_CODE=$(echo "$ADD_RESPONSE" | tail -1)
          RESPONSE_BODY=$(echo "$ADD_RESPONSE" | head -n -1)

          if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "SUCCESS: Build added to test group '$TESTFLIGHT_GROUP_NAME'"
          else
            echo "WARNING: Unexpected response code $HTTP_CODE"
            echo "$RESPONSE_BODY"
            # Don't fail - build was uploaded successfully
          fi

      - name: Clean up keychain
        if: always()
        run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
